{"ast":null,"code":"var _s = $RefreshSig$();\nimport React, { useRef, useEffect } from 'react';\nimport * as poseDetection from \"@tensorflow-models/pose-detection\";\nimport * as tf from \"@tensorflow/tfjs\";\nconst RunPoseMesh = () => {\n  _s();\n  const webcamRef = useRef(null);\n  const canvasRef = useRef(null);\n  useEffect(() => {\n    const setupPoseDetection = async () => {\n      await tf.ready(); // Ensure TensorFlow.js is ready\n      await tf.setBackend('webgl'); // Set the TensorFlow.js backend to WebGL for GPU acceleration\n\n      const net = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, {\n        modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING\n      });\n      const detect = async () => {\n        if (typeof webcamRef.current !== \"undefined\" && webcamRef.current !== null && webcamRef.current.video.readyState === 4) {\n          const video = webcamRef.current.video;\n          const videoWidth = video.videoWidth;\n          const videoHeight = video.videoHeight;\n          webcamRef.current.video.width = videoWidth;\n          webcamRef.current.video.height = videoHeight;\n          canvasRef.current.width = videoWidth;\n          canvasRef.current.height = videoHeight;\n          const poses = await net.estimatePoses(video);\n          console.log(poses);\n\n          // Draw the poses onto the canvas\n          const ctx = canvasRef.current.getContext(\"2d\");\n          ctx.clearRect(0, 0, videoWidth, videoHeight);\n          ctx.drawImage(video, 0, 0, videoWidth, videoHeight);\n          poses.forEach(({\n            keypoints\n          }) => {\n            keypoints.forEach(({\n              x,\n              y,\n              score\n            }) => {\n              if (score > 0.5) {\n                ctx.beginPath();\n                ctx.arc(x, y, 5, 0, 2 * Math.PI);\n                ctx.fillStyle = \"red\";\n                ctx.fill();\n              }\n            });\n          });\n        }\n      };\n      setInterval(detect, 100); // Run pose detection every 100ms\n    };\n    setupPoseDetection();\n  }, []); // Empty dependency array ensures this effect runs only once\n\n  return [webcamRef, canvasRef]; // Return webcam and canvas refs for use in App component\n};\n_s(RunPoseMesh, \"v4cpjlVQ0JCDZnPWaD3Z9DHNiTM=\");\n_c = RunPoseMesh;\nexport default RunPoseMesh;\nvar _c;\n$RefreshReg$(_c, \"RunPoseMesh\");","map":{"version":3,"names":["React","useRef","useEffect","poseDetection","tf","RunPoseMesh","_s","webcamRef","canvasRef","setupPoseDetection","ready","setBackend","net","createDetector","SupportedModels","MoveNet","modelType","movenet","SINGLEPOSE_LIGHTNING","detect","current","video","readyState","videoWidth","videoHeight","width","height","poses","estimatePoses","console","log","ctx","getContext","clearRect","drawImage","forEach","keypoints","x","y","score","beginPath","arc","Math","PI","fillStyle","fill","setInterval","_c","$RefreshReg$"],"sources":["C:/Users/PC/Desktop/CodingStuff/BuildSpace/pose-js/src/components/PoseMesh.js"],"sourcesContent":["import React, { useRef, useEffect } from 'react';\r\nimport * as poseDetection from \"@tensorflow-models/pose-detection\";\r\nimport * as tf from \"@tensorflow/tfjs\";\r\n\r\nconst RunPoseMesh = () => {\r\n  const webcamRef = useRef(null);\r\n  const canvasRef = useRef(null);\r\n\r\n  useEffect(() => {\r\n    const setupPoseDetection = async () => {\r\n      await tf.ready(); // Ensure TensorFlow.js is ready\r\n      await tf.setBackend('webgl'); // Set the TensorFlow.js backend to WebGL for GPU acceleration\r\n\r\n      const net = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, {\r\n        modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,\r\n      });\r\n\r\n      const detect = async () => {\r\n        if (\r\n          typeof webcamRef.current !== \"undefined\" &&\r\n          webcamRef.current !== null &&\r\n          webcamRef.current.video.readyState === 4\r\n        ) {\r\n          const video = webcamRef.current.video;\r\n          const videoWidth = video.videoWidth;\r\n          const videoHeight = video.videoHeight;\r\n\r\n          webcamRef.current.video.width = videoWidth;\r\n          webcamRef.current.video.height = videoHeight;\r\n\r\n          canvasRef.current.width = videoWidth;\r\n          canvasRef.current.height = videoHeight;\r\n\r\n          const poses = await net.estimatePoses(video);\r\n          console.log(poses);\r\n\r\n          // Draw the poses onto the canvas\r\n          const ctx = canvasRef.current.getContext(\"2d\");\r\n          ctx.clearRect(0, 0, videoWidth, videoHeight);\r\n          ctx.drawImage(video, 0, 0, videoWidth, videoHeight);\r\n\r\n          poses.forEach(({ keypoints }) => {\r\n            keypoints.forEach(({ x, y, score }) => {\r\n              if (score > 0.5) {\r\n                ctx.beginPath();\r\n                ctx.arc(x, y, 5, 0, 2 * Math.PI);\r\n                ctx.fillStyle = \"red\";\r\n                ctx.fill();\r\n              }\r\n            });\r\n          });\r\n        }\r\n      };\r\n\r\n      setInterval(detect, 100); // Run pose detection every 100ms\r\n    };\r\n\r\n    setupPoseDetection();\r\n  }, []); // Empty dependency array ensures this effect runs only once\r\n\r\n  return [webcamRef, canvasRef]; // Return webcam and canvas refs for use in App component\r\n};\r\n\r\nexport default RunPoseMesh;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}